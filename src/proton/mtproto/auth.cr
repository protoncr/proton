require "digest"

module Proton::MTProto
  module Auth
    record Step1, nonce : Bytes
    record Step2, nonce : Bytes, server_nonce : Bytes, new_nonce : Bytes
    record Step3, nonce : Bytes, server_nonce : Bytes, new_nonce : Bytes, gab : BigInt, time_offset : Int32

    # The final result of doing the authorization handshake, generated by `create_key`.
    record Finished, auth_key : Crypto::AuthKey, time_offset : Int32, first_salt : Int64

    def self.step1 : Tuple(Bytes, Step1)
      nonce = Random::Secure.random_bytes(16)
      do_step1(nonce)
    end

    # :nodoc:
    def self.do_step1(nonce)
      {TL::Root::ReqPqMultiRequest.new(TL::I128.from_bytes(nonce)).to_bytes, Step1.new(nonce)}
    end

    def self.step2(data : Step1, response : Bytes)
      random_bytes = Random::Secure.random_bytes(32 + 256)
      do_step2(data, response, random_bytes)
    end

    # :nodoc:
    def self.do_step2(data, response, random_bytes)
      nonce = data.nonce
      res_pq = TL::Root::ResPq.from_bytes(response)

      check_nonce(res_pq.nonce.to_bytes, nonce)

      if res_pq.pq.size != 8
        raise Error::InvalidPQSize.new(size: res_pq.pq.size)
      end

      pq = IO::ByteFormat::BigEndian.decode(UInt64, res_pq.pq)
      p, q = Crypto::Factorize.factorize(pq)

      new_nonce = random_bytes[...32].clone

      # Remove the now-used first part from our available random data.
      random_bytes = random_bytes[32...].clone

      # Convert (p, q) to bytes using the least amount of space possible.
      # If we don't do this, Telegram will respond with -404 as the message.
      p_bytes = begin
        buffer = Bytes.new(8)
        IO::ByteFormat::BigEndian.encode(p, buffer)
        if pos = buffer.index { |b| b != 0_u8 }
          buffer = buffer[pos...]
        end
        buffer
      end

      q_bytes = begin
        buffer = Bytes.new(8)
        IO::ByteFormat::BigEndian.encode(q, buffer)
        if pos = buffer.index { |b| b != 0_u8 }
          buffer = buffer[pos...]
        end
        buffer
      end

      # "pq is a representation of a natural number (in binary big endian format)"
      # https://core.telegram.org/mtproto/auth_key#dh-exchange-initiation
      pq_inner_data = TL::Root::PQInnerData.new(
        pq: res_pq.pq,
        p: p_bytes.clone,
        q: q_bytes.clone,
        nonce: TL::I128.from_bytes(nonce),
        server_nonce: res_pq.server_nonce,
        new_nonce: TL::I256.from_bytes(new_nonce)).to_bytes

      # sha_digest + data + random_bytes
      fingerprint = res_pq
        .server_public_key_fingerprints
        .find { |fp| key_for_fingerprint(fp) }

      if !fingerprint
        raise Error::UnknownFingerprints.new(fingerprints: res_pq.server_public_key_fingerprints)
      end

      # Safe because we just found it above
      key = key_for_fingerprint(fingerprint).not_nil!
      ciphertext = Crypto::RSA.encrypt_hashed(pq_inner_data, key, random_bytes)

      req_dh_params = TL::Root::ReqDhParamsRequest.new(
        nonce: TL::I128.from_bytes(nonce),
        server_nonce: res_pq.server_nonce,
        p: p_bytes,
        q: q_bytes,
        public_key_fingerprint: fingerprint,
        encrypted_data: ciphertext).to_bytes

      {req_dh_params, Step2.new(nonce, res_pq.server_nonce.to_bytes, new_nonce)}
    end

    def self.step3(data : Step2, response : Bytes)
      random_bytes = Random::Secure.random_bytes(256 + 16)
      now = Time.now.to_unix.to_i32
      do_step3(data, response, random_bytes, now.to_i32)
    end

    # :nodoc:
    def self.do_step3(data : Step2, response : Bytes, random_bytes : Bytes, now : Int32)
      nonce = data.nonce
      server_nonce = data.server_nonce
      new_nonce = data.new_nonce

      server_dh_params = TL::Root::ReqDhParamsRequest.return_type.from_bytes(response, boxed: true)
      server_dh_params = case server_dh_params
                         when TL::Root::ServerDhParamsFail
                           # Even though this is a failing case, we should still perform
                           # all the security checks.
                           check_nonce(server_dh_params.nonce.to_bytes, nonce)
                           check_server_nonce(server_dh_params.server_nonce.to_bytes, server_nonce)

                           new_nonce_hash = begin
                             sha = Digest::SHA1.new
                             sha.update(new_nonce)
                             sha.final[4...20]
                           end

                           check_new_nonce_hash(server_dh_params.new_nonce_hash.to_bytes, new_nonce_hash)

                           raise Error::DHParamsFail.new
                         when TL::Root::ServerDhParamsOk
                           server_dh_params
                         else
                           raise "Unreachable"
                         end

      # puts server_dh_params.nonce.to_bytes
      # puts server_dh_params.server_nonce.to_bytes

      check_nonce(server_dh_params.nonce.to_bytes, nonce)
      check_server_nonce(server_dh_params.server_nonce.to_bytes, server_nonce)

      if server_dh_params.encrypted_answer.size % 16 != 0
        raise Error::EncryptedResponseNotPadded.new(
          len: server_dh_params.encrypted_answer.size)
      end

      # Complete DH Exchange
      key, iv = Crypto.generate_key_data_from_nonce(server_nonce, new_nonce)

      # sha1 hash + plain text + padding
      plain_text_answer = Crypto.decrypt_ige(server_dh_params.encrypted_answer, key, iv)
      got_answer_hash = plain_text_answer[...20].clone

      # Use an IO explicitly so we know where it ends, and more importantly, where
      # the padding begins.
      plain_text_io = IO::Memory.new(plain_text_answer[20...])

      begin
        server_dh_inner = TL::Root::ServerDhInnerData.tl_deserialize(plain_text_io, boxed: true)
      rescue ex : Error
        raise Error::InvalidDhInnerData.new(ex)
      end

      expected_answer_hash =
        Digest::SHA1.new.update(plain_text_answer[20...(20 + plain_text_io.pos)]).final

      if got_answer_hash != expected_answer_hash
        raise Error::InvalidAnswerHash.new(got: got_answer_hash, expected: expected_answer_hash)
      end

      check_nonce(server_dh_inner.nonce.to_bytes, nonce)
      check_server_nonce(server_dh_inner.server_nonce.to_bytes, server_nonce)

      # Safe to unwrap because the numbers are valid
      dh_prime = BigInt.new(server_dh_inner.dh_prime, IO::ByteFormat::BigEndian)
      g = BigInt.new(server_dh_inner.g)
      g_a = BigInt.new(server_dh_inner.g_a, IO::ByteFormat::BigEndian)

      time_offset = server_dh_inner.server_time - now

      b = BigInt.new(random_bytes[...256], IO::ByteFormat::BigEndian)
      g_b = Crypto::Factorize.modpow(g, b, dh_prime)
      gab = Crypto::Factorize.modpow(g_a, b, dh_prime)

      # Remove the now-used first part from our available random data
      # leaving the remaining 16 bytes.
      random_bytes = random_bytes[256...]

      # IMPORTANT: Apart from the conditions on the Diffie-Hellman prime
      # dh_prime and generator g, both sides are to check that g, g_a and
      # g_b are greater than 1 and less than dh_prime - 1. We recommend
      # checking that g_a and g_b are between 2^{2048-64} and
      # dh_prime - 2^{2048-64} as well.
      # (https://core.telegram.org/mtproto/auth_key#dh-key-exchange-complete)
      one = BigInt.new(1)
      check_g_in_range(g, one, (dh_prime - one))
      check_g_in_range(g_a, one, (dh_prime - one))
      check_g_in_range(g_b, one, (dh_prime - one))

      safety_range = one << (2048 - 64)
      check_g_in_range(g_a, safety_range, (dh_prime - safety_range))
      check_g_in_range(g_b, safety_range, (dh_prime - safety_range))

      # Prepare client DH Inner Data
      client_dh_inner = TL::Root::ClientDhInnerData.new(
        nonce: TL::I128.from_bytes(nonce),
        server_nonce: TL::I128.from_bytes(server_nonce),
        retry_id: 0_i64, # TODO: Use a real retry id
        g_b: g_b.to_slice(IO::ByteFormat::BigEndian)      ).to_bytes

      # sha1(client_dh_inner).digest() + client_dh_inner
      client_dh_inner_hashed = begin
        sha = Digest::SHA1.new.update(client_dh_inner).final
        buffer = Bytes.concat(sha, client_dh_inner)

        # Make sure we pad it ourselves, or else `encrypt_ige` will,
        # introducing randomness.
        pad_len = (16 - (buffer.size % 16)) % 16

        Bytes.concat(buffer, random_bytes[...pad_len])
      end

      client_dh_encrypted = Crypto.encrypt_ige(client_dh_inner_hashed, key, iv)

      set_client_dh_params = TL::Root::SetClientDhParamsRequest.new(
        TL::I128.from_bytes(nonce),
        TL::I128.from_bytes(server_nonce),
        client_dh_encrypted).to_bytes
      step3 = Step3.new(nonce, server_nonce, new_nonce, gab, time_offset)

      {set_client_dh_params, step3}
    end

    private record DhGenData, nonce : Bytes, server_nonce : Bytes, new_nonce_hash : Bytes, nonce_number : UInt8

    # The last step of the process to generate an authorization key.
    def self.create_key(data : Step3, response : Bytes)
      nonce = data.nonce
      server_nonce = data.server_nonce
      new_nonce = data.new_nonce
      gab = data.gab
      time_offset = data.time_offset

      dh_gen = TL::Root::SetClientDhParamsRequest.return_type.from_bytes(response)
      dh_gen = case dh_gen
               when TL::Root::DhGenOk
                 DhGenData.new(dh_gen.nonce.to_bytes, dh_gen.server_nonce.to_bytes, dh_gen.new_nonce_hash1.to_bytes, 1_u8)
               when TL::Root::DhGenRetry
                 DhGenData.new(dh_gen.nonce.to_bytes, dh_gen.server_nonce.to_bytes, dh_gen.new_nonce_hash2.to_bytes, 2_u8)
               when TL::Root::DhGenFail
                 DhGenData.new(dh_gen.nonce.to_bytes, dh_gen.server_nonce.to_bytes, dh_gen.new_nonce_hash3.to_bytes, 3_u8)
               else
                 raise "Unreachable"
               end

      check_nonce(dh_gen.nonce, nonce)
      check_server_nonce(dh_gen.server_nonce, server_nonce)

      auth_key = begin
        gab_bytes = gab.to_slice(IO::ByteFormat::BigEndian)
        skip = 256 - gab_bytes.size
        Crypto::AuthKey.from_bytes(gab_bytes[skip...])
      end

      new_nonce_hash = auth_key.calc_new_nonce_hash(new_nonce, dh_gen.nonce_number)
      check_new_nonce_hash(dh_gen.new_nonce_hash, new_nonce_hash)

      first_salt = begin
        bytes = Bytes.new(8) do |i|
          new_nonce[i] ^ server_nonce[i]
        end
        IO::ByteFormat::LittleEndian.decode(Int64, bytes)
      end

      # 1 for DhGenOk
      if dh_gen.nonce_number == 1
        Finished.new(auth_key, time_offset, first_salt)
      else
        raise Error::DHGenFail.new
      end
    end

    def self.check_nonce(got : Bytes, expected : Bytes)
      if got != expected
        raise Error::InvalidNonce.new(got, expected)
      end
      true
    end

    def self.check_server_nonce(got : Bytes, expected : Bytes)
      if got != expected
        raise Error::InvalidServerNonce.new(got, expected)
      end
      true
    end

    # Helper function to avoid the boilerplate of checking for invalid
    # new nonce hash.
    def self.check_new_nonce_hash(got : Bytes, expected : Bytes)
      if got != expected
        raise Error::InvalidNewNonceHash.new(got, expected)
      end
      true
    end

    def self.check_g_in_range(value, low, high)
      if low >= value || value >= high
        raise Error::GParameterOutOfRange.new(value, low, high)
      end
      true
    end

    # Find the RSA key's `(n, e)` pair for a certain fingerprint.
    def self.key_for_fingerprint(fingerprint fp)
      case fp
      # New
      when 847625836280919973
        Crypto::RSA::Key.new(
          BigInt.new(
            "220819465310378335405242605806607740322074765211971211287403587614863647634670878287" +
            "668739723380190789768549865310764847727717353997014245661770399268553567194977364392" +
            "894552862772021139005095542660573024665289852536483183141292468252196401973561656267" +
            "742769306726889732787126148000660375315993750447507535801264156130863726043123200143" +
            "589943941316670228617675398792321494615799223164895326821657467625696517637945009236" +
            "436567532788878719556762535266616944593700478432866858596887564292931841482023793568" +
            "024888058627460460719218309218402730621245710733363692107034009858514314912959101871" +
            "79045081526826572515473914151"),
          BigInt.new("65537"))
      when 1562291298945373506
        Crypto::RSA::Key.new(
          BigInt.new(
            "239787585531066319920025803056200058350604006924924108309112536909689851617709195710" +
            "232132687346376557964357792385775295981573031539298474884342620372162430923742621440" +
            "867015525884461621983733125129778911358645449073836665607424981781555727338319047852" +
            "323102276442616888738413362642911238061581640864167233966189934407003016706948123771" +
            "022257204385420270676992767813568816492727591027120531069177564705960379693589351621" +
            "265539215369610798846984484644800187151288255163378182167196999634639961614337656180" +
            "414753217015500490059504675520641339357682196967436078326673857159682972850431805672" +
            "81391541729832333512747963903"),
          BigInt.new("65537"))
      when -5859577972006586033
        Crypto::RSA::Key.new(
          BigInt.new(
            "227186469790214450868053002678738365519522642926809299832153332228942632712625254046" +
            "359177328448795104790267271192196322822630229869267159269056758293691192760870342084" +
            "781034974965571600620327696142354804803364589784832350189946230191249567287062856538" +
            "793923592959377774809982853278555363429423774834339419734357579597589397321338451148" +
            "739671699068968378817675551788937005323568886315574782142252361428021788824056608675" +
            "092080281178957790924877730431633480859060224714546303644301268782521399176141786369" +
            "344121036238690729040538279332448092153642428854762088520614712031891282812923929559" +
            "60922615335169478055469443233"),
          BigInt.new("65537"))
      when 6491968696586960280
        Crypto::RSA::Key.new(
          BigInt.new(
            "240377668010086507429807704190850677085990001064683591155038083613355105493343994207" +
            "392463452111614420478008365190335447470258516939682692854750395552317733137244625649" +
            "086662398408982048331832909392964557763674175726783626020411854219104561642817508406" +
            "511405992667163664312218604631636780446753847971038318246971373945592087232530472259" +
            "969943741034887536372285690819110626042599732194665275320550012065490205397678365497" +
            "155480813918299065566453847626968400190837432143312454560236663323602787390939258088" +
            "847460791746651225181961628465051963345139101358124808781815768026701324126815957471" +
            "04670774040613733524133809153"),
          BigInt.new("65537"))
        # Old
      when -4344800451088585951
        Crypto::RSA::Key.new(
          BigInt.new(
            "244034466491450680568240817441120653464461360662973074738682938950863325081012519649" +
            "195877459843113728530532534578352088298244284418749465566599535192133827483195182147" +
            "659856626636808182779897367795063188680037552164025389459003887068981012865481872867" +
            "169591001029396363334524573086194548218451961095441576010963591482414359221256024492" +
            "631645122908543669300138258081024030723177382663832371913137144821873266431446036338" +
            "772190282626975938824104032739590743508499230417656396733357756058423115781097264031" +
            "652988750589417653626229360978397753800705729210075862661154769758191753199955279160" +
            "42178582540628652481530373407"),
          BigInt.new("65537"))
      when -7306692244673891685
        Crypto::RSA::Key.new(
          BigInt.new(
            "250814078104102250309317227348860592475985151575164703972425458675501165984369685535" +
            "514655546537452016349777793808847745344573867959220038150720715583705972903687378629" +
            "818712773128239428221448025090554925121455897347729072252590381134149403844464931117" +
            "369996686528484406556031576659037215172249341423014563129945475916260815171627588084" +
            "399797453280303767969536600426298689020131777517033855014126405602750671715557637254" +
            "213770650952310955172012410698568889333582807296742734221172015965119786458785443081" +
            "020767464654689559106591455326992385769789010111124756989636660915107787773569663511" +
            "91806495199073754705289253783"),
          BigInt.new("65537"))
      when -5738946642031285640
        Crypto::RSA::Key.new(
          BigInt.new(
            "223473376446219978303237972175834488338496275952865055273282147957128745354171494575" +
            "672952155231992128998721226740239367131240241246764882048893575631044522501877254378" +
            "158196807994413764341629078892885268632230043809067664517817024358610400492931899797" +
            "557574283662405704573722263239435229358440868383557287675654151151312389509940490419" +
            "506990065584411632065236965462970060144165761233455456010045085370891928695584809481" +
            "396791823288105319424189211133288047494853494415039275705687789059186968831745755103" +
            "855528456254814909006597184138922162215396847177734833262408720617867598680406239355" +
            "92404144262688161923519030977"),
          BigInt.new("65537"))
      when 8205599988028290019
        Crypto::RSA::Key.new(
          BigInt.new(
            "245734552079575650478700117852542153909189123698149475417853862995168270035086593460" +
            "694168406229224167796520503191967010772750603531781427969636820243478583983199261196" +
            "392655554102564554710164002616309178133375152479546385553252803929989507565128797488" +
            "734228967985798898202483586369376598723799486168229021106969864816387762268607774806" +
            "846537560421666106335134041295180405490775512270822620666022862083389520160356373347" +
            "875649729912082529289518764635554567159237431813598261240839637580094848673463184838" +
            "725529776525880899287618068972232315009705001860199910321760605798163483224518645847" +
            "43414550721639495547636008351"),
          BigInt.new("65537"))
      end
    end
  end
end

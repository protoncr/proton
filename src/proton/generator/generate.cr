require "code_writer"
require "tl_parser"

include TLParser

AUTOGEN_MESSAGE = "This file is autogenerated. It will be overwritten."

OUTPUT_DIR    = Path["../tl"].expand(__DIR__).to_s
INPUT_FILE    = Path[OUTPUT_DIR, "data/api.tl"].expand(__DIR__).to_s
SCHEMA_FILE   = Path[OUTPUT_DIR, "data/mtproto.tl"].expand(__DIR__).to_s
OUTPUT_FILE   = Path[OUTPUT_DIR, "api.cr"].expand(__DIR__).to_s
TYPES_DIR     = Path[OUTPUT_DIR, "types"]

WEIRD_TYPES = ["Bool", "X", "Type"]
PEERS_TO_PATCH = [
    "InputPeer",
    "Peer",
    "InputUser",
    "User",
    "UserFull",
    "Chat",
    "ChatFull",
    "InputChannel",
]

NAMED_AUTO_CASTS = [{"chat_id", "int"}]
NAMED_BLACKLIST = ["discardEncryption"]
AUTO_CASTS = [
    "InputPeer",
    "InputChannel",
    "InputUser",
    "InputDialogPeer",
    "InputNotifyPeer",
    "InputMedia",
    "InputPhoto",
    "InputMessage",
    "InputDocument",
    "InputChatPhoto",
]

def classify(str : String)
  str.split('_')
     .map(&.capitalize)
     .join("")
end

record TypeDef, namespace : Array(String), name : String, constructors : Array(String)
record TLParams, types : Array(TypeDef), functions : Array(Definition), constructors : Array(Definition) do
  def self.from_tl(content : String)
    defs = TLParser.parse(content)
    types = {} of Type => TypeDef
    constructors = [] of Definition
    functions = [] of Definition

    defs.each do |defn|
      if defn.category.functions?
        functions << defn
      else
        if !types.has_key?(defn.type.name)
          types[defn.type] = TypeDef.new(
            namespace: defn.namespace,
            name: defn.name,
            constructors: [] of String
          )
        end

        types[defn.type].constructors.push((defn.namespace + [defn.name]).join('.'))
        constructors.push(defn)
      end
    end

    new(types: types.values, functions: functions, constructors: constructors)
  end
end

def group_by_ns(arr : Array(U)) forall U
  arr.reduce({} of Array(String) => Array(U)) do |acc, o|
    acc[o.namespace] ||= [] of U
    acc[o.namespace] << o
    acc
  end
end

def write_root_module
  File.open(OUTPUT_FILE, mode: "w+") do |file|
    writer = CodeWriter.new(buffer: file, language_settings: CodeWriter::LANGUAGES["crystal"])
    writer.comment(AUTOGEN_MESSAGE)
          .blank_line
          .puts("require \"./helpers\"")
          .puts("require \"./tlobject\"")
          .puts("require \"./types/**/*\"")
          .puts("require \"./functions/**/*\"")
  end
end

def write_module(types_by_ns, constructors_by_ns, functions_by_ns, namespaces, ns)
  file_path = Path[TYPES_DIR, "#{ns.empty? ? "root" : ns.join("/")}.cr"]
  File.open(file_path, mode: "w+") do |file|
    writer = CodeWriter.new(buffer: file, language_settings: CodeWriter::LANGUAGES["crystal"])

    # render_constructors(writer, constructors_by_ns[ns])
    # render_functions(writer, functions_by_ns[ns])

    writer.comment("Type aliases")
    writer.puts("alias TypeEntityLike = EntityLike") if ns.empty?
    # render_types(writer, types[ns])

    if ns.empty?
      pp functions_by_ns[ns]
      writer.comment("All requests")
            .print("alias AnyRequest = ")
            .print(functions_by_ns[ns].map { |func| (func.namespace.map(&->classify(String)) + [classify(func.name.capitalize)]).join("::") }.join(" | "))
    end
  end
end

api_content = File.read(INPUT_FILE)
schema_content = File.read(SCHEMA_FILE)

api_config = TLParams.from_tl(api_content)
schema_config = TLParams.from_tl(schema_content)

types = api_config.types + schema_config.types
functions = api_config.functions + schema_config.functions
constructors = api_config.constructors + schema_config.constructors

types_by_ns = group_by_ns(types)
functions_by_ns = group_by_ns(functions)
constructors_by_ns = group_by_ns(constructors)

namespaces = (types_by_ns.keys + functions_by_ns.keys + constructors_by_ns.keys).uniq!

Dir.mkdir_p(TYPES_DIR)

write_root_module

namespaces.each do |ns|
  write_module(types_by_ns, constructors_by_ns, functions_by_ns, namespaces, ns)
end
